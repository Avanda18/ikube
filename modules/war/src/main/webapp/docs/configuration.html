<html>
	<head>
		<title>Ikube Configuration</title>
		<link href="../style/style-white.css" rel="stylesheet" type="text/css" media="screen" />
		<script src="../js/ikube.js" type="text/javascript"></script>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
	</head>
	
	<body>
		<table class="table-content">
			<tr id="content">
				<td>
					<table class="table-content">
						<tr>
							<td class="top-content">
								<span class="top-content-header">configuration</span>
							</td>
							<td class="top-content" style="padding-left: 150px">
								<script type="text/javascript">writeDate();</script>
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td class="td-content">
					<strong>Basics</strong><br>
					Configuration is done via Spring configuration files. At the top of the index hierarchy are IndexContext(s). An index 
					context defines an index. There are parameters like the name, the maximum age that the index can become etc. Please refer 
					to the table below for a full account of the available parameters and their definitions:<br><br>
				</td>
			</tr>
			<tr>
				<td class="td-content">
					<table>
						<thead>
							<tr>
								<th colspan="2">IndexContext definition parameters</th>
							</tr>
						</thead>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>indexName</td>
							<td>
								This is the name of the index. The name appended to the index directory path will be the location of this particular 
								index. Also 	the index will be accessed via this name when using the web service. This name must be unique within the 
								configuration.
							</td>
						</tr>
						<tr>
							<td>maxAge</td>
							<td>
								The maximum age the index can become before a new one is generated. An index is triggered by an index 
								passing the maximum age. This is defined in milli seconds. 
							</td>
						</tr>
						<tr>
							<td>throttle</td>
							<td>
								This parameter defines the time each thread will sleep between index items. In the case of the web crawler, 
								 to avoid stressing the server, each thread will sleep between reading urls. In the case of a database index each 
								 thread will sleep between records for this period of time, defined in milli seconds. 
							</td>
						</tr>
						<tr>
							<td>mergeFactor</td>
							<td>
								Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
								on the merge factor. Essentially it is the number of segments that are kept in memory during the merge, which could be 
								when the index is optimized or committed.      
							</td>
						</tr>
						<tr>
							<td>bufferedDocs</td>
							<td>
								Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
								on the buffered documents. This is the number of documents that will be stored in memory before being committed to the 
								index during indexing.
							</td>
						</tr>
						<tr>
							<td>bufferSize</td>
							<td>
								Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
								on the buffer size. This is the maximum size of the memory that Lucene can use before it commits the documents. A 
								fail safe for out of memory errors.
							</td>
						</tr>
						<tr>
							<td>maxFieldLength</td>
							<td>
								Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
								on the maximum field length.
							</td>
						</tr>
						<tr>
							<td>compoundFile</td>
							<td>
								Whether Lucene should use a compound file or not. During the indexing there will be several files generated by Lucene. At the 
								end the index will be optimized and potentially all the files will be merged into one file. With large indexes this is quite a long process, 
								spanning hours. For more information on why and when to use a compound file please refer to the 
								<a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> 	documentation.
							</td>
						</tr>
						<tr>
							<td>batchSize</td>
							<td>
								The number of records to retrieve from the database in each batch. For each batch there is a select on the database, increasing 
								the batch size means less selects and larger result sets. This does not have a very large performance influence unless the batch size 
								is 1 for example as selects are generally fast.
							</td>
						</tr>
						<tr>
							<td>internetBatchSize</td>
							<td>
								The batch size for the crawler. Each thread will get a batch of urls to read and index. Once again there is no real performance gain 
								between 100 and 1000 in the batch size.
							</td>
						</tr>
						<tr>
							<td>maxReadLength</td>
							<td>
								The maximum size to read from any resource, could be a blob in the database or a file on the file system. Indexing requires that 
								the data be stored in memory, certainly for PDF files for example. As such this parameter is quite important. In cases where there 
								is a PDF document of several hundred megabytes and 20 threads crawling the database, this would result in an out of  memory error. 
								Unfortunately this also means that there will be some data lost if the files are very big. Lucene can handle readers as input, which 
								can be on the file system but the performance loss is too great, certainly with large volumes is was found not to be practical. This 
								parameter should be set with due care. 
							</td>
						</tr>
						<tr>
							<td>indexDirectoryPath</td>
							<td>
								The path to the indexes. This path combined with the index name will determine the exact location on the file system where  
								the index is written. In the case where the directory path is for example ./indexes (as in the default configuration), Ikube will 
								create the folder in the working folder for the Jvm. This path can be on the network somewhere, provided the file share where 
								it is is accessible to the application. In the case of a cluster it is desirable to have all the servers write their part of the index to 
								a file share as this means that there will be only one copy of the index. If the index path is defined as ./indexes, then each server 
								will synchronize with the other servers, duplicating the index on each machine. Of course this facilitated complete failover in the 
								case where one server goes down, but if the indexes are 1 terabyte each then each server must have at least 2 terabytes of disk 
								space, one for the current index and one for the index being generated. 
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td class="td-content">
					Sources of data to index are defined as indexables. An indexable can be a url or a table structure in a database. Each indexable needs 
					to be defined separately. Indexables are added to the index context in the configuration, please refer to the 
					<a href="http://code.google.com/p/ikube/source/browse/#svn%2Ftrunk%2Fmodules%2Fcore%2Fsrc%2Fmain%2Fresources%2FMETA-INF" 
						target="_top">default configuration</a> 
					for an example. We'll start at the top with a database definition of an indexable. Tables are defined as beans with the following parameters:
				</td>
			</tr>
			<tr>
				<td class="td-content">
					<table>
						<thead>
							<tr>
								<th colspan="2">IndexableTable definition parameters</th>
							</tr>
						</thead>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>name</td>
							<td>
								The name of the table. This will be used to generate the sql to access the table.
							</td>
						</tr>
						<tr>
							<td>schema</td>
							<td>
								 The schema in the database where the table is, also used to generate the sql to access the database.
							</td>
						</tr>
						<tr>
							<td>predicate</td>
							<td>
								 This is an optional parameter where a predicate can be defined to limit the results. A typical example is 
								 where faq.faqid &lt; 10000. 
							</td>
						</tr>
						<tr>
							<td>primary</td>
							<td>
								Whether this table is a top level table. This will determine when the data collected while accessing the table 
								hierarchy will be written to the database.
							</td>
						</tr>
						<tr>
							<td>dataSource</td>
							<td>
								The reference to the datasource where the table is. The datasource must be defined in the Spring configuration, using 
								perhaps C3p0 as the pooled datasource provider.
							</td>
						</tr>
						<tr>
							<td>children</td>
							<td>
								The children of the table. Typically this is a list of columns and child tables.
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					As mentioned previously the sql to access the data is generated from the configuration. Tables can be nested within each 
					other as is normally the case with tables in a relational database. If a table is defined as a primary table and a child table is added 
					to the child indexables of the table then the logic to index the tables will be as follows:<br><br>
					
					1) Select the records from the primary table using the batch size defined in the index context and the predicate<br>
					2) Go to the next result in the result set for the table<br>
					3) Using the foreign key defined in the secondary table definition select the records from the second table<br> 
					4) Iterate over the second table results and index the data for the columns<br>
					5) Return to the primary table and move to the next result in the result set<br><br>
					
					Here is a solid example of the mechanism of indexing tables. We will index two tables, related to each other by a foreign key, the 'faq' 
					table and the 'attachments' table. The attachments table is 
					related to the faq table by a foreign key attachment.faqId =&gt; faq.id. We want to index all the data in the faq table and include all the 
					attachments for each faq. The logic during indexing is as follows.<br><br>
					
					1) select id, question, answer from faq where id &gt; 1000 and id &lt; 2000<br>
					2) ResultSet.next()<br>
					3) Extract column data and populate the Lucene document with the fields<br>
					4) select id, name, attachment from attachment where faq.id = 1000<br>
					5) ResultSet.next()<br>
					6) Extract column data and populate the Lucene document with the fields<br>
					7) Goto 5 until result set is depleted<br>
					8) Goto 2 until records are depleted<br>
					9) Goto 1, incrementing the batch, i.e. the id until there are no more records<br><br>
					
					The result of this is a Lucene document with the following fields and values:<br><br>
					
					&lt;{id=schema.faq.1}, {question=where is Paris}, {answer=In France}, {name=documentone.doc}, 
					{attachment=Paris and Lyon are both situated in France}&gt;<br><br>
					
					The configuration of tables can be arbitrarily complex, nesting depth can be up to 10 tables or more. Testing has only been done 
					to a depth of seven nested tables. In the unit test configuration the depth is four nested tables. With each level in the table hierarchy 
					there needs to be a select on the child table. This has a negative exponential performance effect on the indexing speed as with each 
					table there needs to be a select. For example:<br><br>
					
					* faq - 1000 records<br>
					* attachment - 10000 records, one for each faq<br> 
					* Version - 10000 records, one for each attachment<br><br>
					
					The selects on the database will be:<br><br>
					
					* faq - 1<br>
					* attachment - 1000<br>
					* version - 10000000<br><br>
					
					As you can see ten million selects on the version table could be time consuming. Increasing the size of the 
					faq table will have an exponential effect on the time it takes to index the data. In this case it could be interesting 
					to create two indexes, one for the versions and one for the faqs.
				</td>
			</tr>
			<tr>
				<td>
					Columns are defined and added to the tables as children. Below is a table of parameters that can be defined for columns.
				</td>
			</tr>
			<tr>
				<td class="td-content">
					<table>
						<thead>
							<tr>
								<th colspan="2">IndexableColumn definition parameters</th>
							</tr>
						</thead>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>name</td>
							<td>
								The name of the column.
							</td>
						</tr>
						<tr>
							<td>idColumn</td>
							<td>
								Whether this is the id column in the table.
							</td>
						</tr>
						<tr>
							<td>nameColumn</td>
							<td>
								This is used during indexing. For example in the case where there is a blob in the attachments table, and the name of the document 
								is in the 'name' column, this parameter is used to determine the mime type. If the name is document.doc, and there is a blob of the document 
								data then during indexing the .doc suffix will be used to get the correct parser to extract the text from the document, i.e. the Word parser.
							</td>
						</tr>
						<tr>
							<td>fieldName</td>
							<td>
								 The name of the field in the Lucene index. This allows columns to have separate field names, increasing the flexibility when searching. For 
								 example if there are timestamps for creation and they are defined as separate Lucene fields then searches like timestamp &gt; 12/12/2010 
								 AND timestamp &lt; 12/12/2011 are possible.
							</td>
						</tr>
						<tr>
							<td>foreignKey</td>
							<td>
								  The reference to the foreign key in the 'parent' table. This is used to select the records from the 'child' table referring to the parent id.
							</td>
						</tr>
						<tr>
							<td>analyzed</td>
							<td>
								A Lucene parameter, whether the data should be analyzed. Generally this is true.
							</td>
						</tr>
						<tr>
							<td>stored</td>
							<td>
								A Lucene parameter, whether the data should be stored in the index. Generally this is true. Of course if there is very large volumes of data 
								then storing the data could be prohibitively expensive, in terms of disk space and time. The write time of the index is a large proportion of the 
								indexing time.   
							</td>
						</tr>
						<tr>
							<td>vectored</td>
							<td>
								A Lucene parameter, whether the data should vectored. Generally this is true.
							</td>
						</tr>
					</table>
				</td>
			</tr>
			<tr>
				<td>
					Please refer to the 
					<a href="http://code.google.com/p/ikube/source/browse/#svn%2Ftrunk%2Fmodules%2Fcore%2Fsrc%2Fmain%2Fresources%2FMETA-INF"
						target="_top">default configuration</a> 
					for a complete example of a nested table configuration.
				</td>
			</tr>
			
			<tr>
				<td>
					<br>TODO - web site configuration<br>
				</td>
			</tr>
			
			<tr>
				<td><br>TODO - email configuration<br></td>
			</tr>
			
			<tr>
				<td><br>TODO - file share configuration<br></td>
			</tr>
			
		</table>
	</body>
</html>