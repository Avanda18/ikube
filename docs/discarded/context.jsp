<%@ page errorPage="/WEB-INF/jsp/error.jsp" %>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>

<table class="table-content" width="100%">
	<tr><td colspan="2"><span style="float: right;"><script type="text/javascript">writeDate();</script></span></td></tr>
	<tr>
		<td colspan="2">
			<strong>context</strong>&nbsp;
			Internet and file system configurations are not particularly difficult, but database configuration is not trivial and generally would 
			need a developer to administer. Over and above that he/she would need to have knowledge of Spring. Please refer to 
			the <a href="<c:url value="/documentation/quickstart.html" />" >quick start</a> to get Ikube running in a Tomcat as the 
			configuration tutorial will use this as a starting point.
		</td>
	</tr>
	<tr>
		<td colspan="2">
			All configuration is done via Spring configuration files. The default configuration is packed in the Ikube zip. Unpack the zip 
			and copy the 'ikube' folder to the bin folder of Tomcat.
			<br><br>
			If the configuration files are not found in the bin(startup) directory then the result is undefined, probably a crash, due to the security 
			beans not being present in the configuration files.
		</td>
	</tr>
	<tr>
		<td colspan="2">
			Ikube can index data bases, internet/intranet, file systems and email. For each internet site, database or file share you need to 
			define an indexable. The exact structure of the configuration files is not important, all you need to do is add your configuration file 
			to the $TOMCAT_INSTALL_BIN/ikube directory, and call it spring-client-*.xml replacing the asterisk with a meaningful name for 
			your configuration, perhaps spring-client-custom.xml for example. 
			
			There is a spring-client.xml file that is a working example of a configuration. This file can be modified to add your internet sites 
			and databases.
 		</td>
	</tr>
	
	<tr><td colspan="2">&nbsp;</td></tr>
	
	<tr>
		<td colspan="2">
			The index context is the top level object in the configuration. It will contain the internet site configurations and database 
			configurations, essentially a wrapper for a Lucene index:<br><br>
			
			<img src="<c:url value="/img/index.context.xml.jpg" />" alt="The default index context" /><br><br>
		</td>
	</tr>
	
	<tr>
		<th>Parameter</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>indexName</td>
		<td> 
			This is the name of the index. This must be unique in the configuration, i.e. there can't be two indexes with 
			the name of 'MyIndex'. This will be used for accessing the correct index during the search and all other system 
			related functions.
		</td>
	</tr>
	<tr>
		<td> maxAge</td>
		<td> 
			The maximum age the index can become before a new one is generated. An index is triggered by an index 
			passing the maximum age. This is defined in minutes. 
		</td>
	</tr>
	<tr>
		<td>compoundFile</td>
		<td> 
			Whether Lucene should use a compound file or not. During the indexing there will be several files generated by Lucene. At the 
			end the index will be optimized and potentially all the files will be merged into one file. With large indexes this is quite a long process, 
			spanning hours. For more information on why and when to use a compound file please refer to the 
			<a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation.
		</td>
	</tr>
	<tr>
		<td> bufferedDocs</td>
		<td> 
			Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
			on the buffered documents. This is the number of documents that will be stored in memory before being committed to the 
			index during indexing. Generally though you don't need to change this, the default is 100, which is fine for most users.
		</td>
	</tr>
	<tr>
		<td> bufferSize</td>
		<td> 
			Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
			on the buffer size. This is the maximum size of the memory that Lucene can use before it commits the documents. A 
			fail safe for out of memory errors. Once again the default is probably fine for most users at 128 meg.
		</td>
	</tr>
	<tr>
		<td>batchSize</td>
		<td> 
			The number of records to retrieve from the database in each batch. For each batch there is a select on the database, increasing 
			the batch size means less selects and larger result sets. This does not have a very large performance influence unless the batch size 
			is 1 for example as selects are generally fast. However please note that if you have a database that has blobs in it, and you have a batch 
			size of 10 000, the database will materialize the blob in some cases, like Db2, and if the blobs are 5 000 bytes then the database will 
			need 50 000 000 bytes available. In Db2 this will throw a -4477 error if I remember correctly. As well as this the table handler is multi 
			threaded which will compound the effect. The recommended batch size is 100.
		</td>
	</tr>
	<tr>
		<td>internetBatchSize</td>
		<td> 
			The batch size for the crawler. Each thread will get a batch of urls to read and index. Once again there is no real performance gain 
			between 100 and 1000 in the batch size. The default is 100, this should e fine for most users.
		</td>
	</tr>
	<tr>
		<td> mergeFactor</td>
		<td> 
			Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
			on the merge factor. Essentially it is the number of segments that are kept in memory during the merge, which could be 
			when the index is optimized or committed.
		</td>
	</tr>
	<tr>
		<td> maxFieldLength</td>
		<td>
			Refer to the <a href="http://lucene.apache.org/java/docs/index.html" target="_top">Lucene</a> documentation for information 
			on the maximum field length.
		</td>
	</tr>
	<tr>
		<td>maxReadLength</td>
		<td> 
			The maximum size to read from any resource, could be a blob in the database or a file on the file system. Indexing requires that 
			the data be stored in memory, certainly for PDF files for example. As such this parameter is quite important. In cases where there 
			is a PDF document of several hundred megabytes and 20 threads crawling the database, this would result in an out of  memory error. 
			Unfortunately this also means that there will be some data lost if the files are very big. Lucene can handle readers as input, which 
			can be on the file system but the performance loss is too great, certainly with large volumes is was found not to be practical. This 
			parameter should be set with due care. The recommended size is 10 meg, keeping in mind that this will result in a least 1 gig of 
			memory required for Ikube. In a high volume environment the recommended memory for Ikube would be dependant on the volumes 
			but at least 3 gig.
		</td>
	</tr>
	<tr>
		<td> throttle</td>
		<td> 
			This parameter defines the time each thread will sleep between index items. In the case of the web crawler, 
			 to avoid stressing the server, each thread will sleep between reading urls. In the case of a database index each 
			 thread will sleep between records for this period of time, defined in milli seconds. 
		</td>
	</tr>
	<tr>
		<td>indexDirectoryPath</td>
		<td> 
			The path to the indexes. This path combined with the index name and the server ip address will determine the exact location on the 
			file system where the index is written. This path can be relative, for example ./indexes. In this case Ikube will create the directory that it needs in 
			the dot folder, i.e. where the Jvm was started. In the case of a Tomcat install this folder will be TOMCAT_INSTALL/bin/indexes. 
			In the case of a cluster the path needs to be defined for all the servers, and in the same place as in the default configuration, it is 
			D:/cluster/indexes. All the servers will then write their portion of the index to this position, and consequently they will also all read 
			and search the index at this location. To reiterate, for a single server the relative path ./indexes is fine but for a cluster the path 
			needs to be on the network something like /mnt/disk-one/path/to/indexes. 
		</td>
	</tr>
	<tr>
		<td>indexDirectoryPathBackup</td>
		<td> 
			The path to the backup indexes. As in the above this needs to be defined differently for a single server and a cluster. This is as the 
			name suggests the backup indexes. Generally an index will take several hours if not days and weeks to generate, in the case that the 
			index becomes corrupt or the disk fails for some obscure reason, the backup index will be copied into the index path. This is an important 
			fail over and recovery parameter. Note of course that there would need to be space for two indexes at least, the current one, the backup 
			index and any indexes that are being generated.
		</td>
	</tr>
	<tr>
		<td>indexables</td>
		<td> 
			These are the sources of data that will be indexed, like a web site and a database for example. They are defined as children 
			in the index context. Indexables and their definitions are described in the Database/File system/Email and Internet configuration pages
			from the menu.
		</td>
	</tr>
	
	<tr>
		<td colspan="2">&nbsp;</td>
	</tr>
	
</table>