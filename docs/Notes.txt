Ikube is an 'enterprise search' application written in Java.

The advantage of Ikube over other products is multiple:

1) Complex database data structures, i.e. hierarchical tables
2) Very large volumes of data
3) The ability to do complex queries using Lucene
4) Customisability, i.e. adding datasources or strategies
5) Data that is almost impossible to get to
6) ...

This is an example of complex search requirements:

You have an application in the healthcare environment. You data is patient data, i.e. John Doe, age 37, address, doctors' reports(in PDF for example), of course visits to the hospitals and doctors, prescriptions, diseases and so on, spread out in the database, as is normally the case. Perhaps some data on the file share somewhere as well. You want to now search for all prescriptions of ampicillin between 12/05/08 and 12/06/08 and the results need to be exact.

To facilitate this the index must contain fields for the prescriptions and their dates. You would also like to search for patients that had ampicillin between these dates, and perhaps from a particular area. This is a complex search requirement which would quite easily be handled by Ikube. The data in each column for name, prescriptions(drug and dates prescribed) and the prescribing hospital would be configured in the index. The search would then span these fields as in the following way:

Prescription date > 12/05/08 AND < 12/06/08
Prescription drug = ampicillin
Location = Paris

Because all the columns in the database have to have corresponding fields in the index each column needs to be configured separately. To allow this flexibility the configuration has to be flexible too.

Ikube is geared to high volumes of data. Generally anything less than 1 gig records in the database of 1 meg documents on an intranet you would be better off using something simpler, certainly there are products that are configurable by a layman rather than a Java developer. The cost of these systems could run into the hundreds of thousands though.

With flexibility and functionality comes complexity and Ikube is no exception. Configuration requires understanding of several factors and I dare say only Java developers would be able to configure an index. To configure indexes one would need to keep in mind:

1) The volume of data, and where the index would be stored. Indexes can have the data stored in them or not. Typically indexes that have the stored data will be 30% of the size of the original data. Will there be sufficient space on the disk for two indexes? One current and one being generated.
2) Network speed and throughput. If the indexes are stored on an external disk then they will be read across the network. Generally this is fast and is in fact the best configuration. In a cluster all the machines will then write their part of the index to this position on the network and they would then all read from the same index. In this way there is only one common index.
3) In a cluster do you want each machine to have a unique complete index. This would facilitate full fail-over functionality as each machine will have a full index(they will synchronise with each other). However if the index size is 1 terabyte then each each server will have to have at least 2 tera of disk space, and then more for scaling when the data volume increases.
4) Where is the data and in what form. Ikube is geared towards database data. How fast is the database? If the database is not particularly fast one thread per server would be enough in a cluster. However if the database is very fast and there is a lot of data(1++ gig) then to facilitate the indexing process more than one thread can be configured per server. Volume testing is done on DB2, quad core 8 gig server with three Jvms and 10 threads per Jvm. The indexing speed for a two level table hierarchy is around 10 000 to 15 000 records per second. The data contains no blobs(which are typically slow to index) and there is a field in the Lucene index for each column in each table. Of course benchmarks need to be read within the environment context.
5) ...

The list goes on. The decision to use Ikube is not a trivial one, and requires investment of time and energy to understand how to configure it. To do a similar search using another product like Autonomy for example would cost upwards of â‚¬100 000. I am guessing of course but for a billion records(I am not even sure this volume possible, or this search) it will surely be in the millions of Euro, once again just a guess.

Ikube is Spring enabled so it can run stand alone or in a server. The data access is via a web service to allow multi platform access.

There are four major datasource types, internet/intranet, database, file share and mail. The internet crawler is multi threaded per Jvm but not clusterable. Generally the web server will be the bottleneck, not the indexing process. When running an index one server will do all the documents from one internet datasource. The database indexing is multi-threaded per Jvm and clusterable. Each server is balanced acording to how fast it is. This is perfectly acceptable as normally the bottleneck will be the database in any case, or the network. With blobs it is the database loading the blobs, as we all know, although it is convenient to pop some blobs in a database, relational databases are not really designed for this, and the performance is not even close to a file system in terms of read.

File shares and mail are single threaded. Generally one thread is more than adequate for a file system and a mail account.

Configuration is done via Spring. A typical example would be a web site, a file share and a database. For example this bean describes the index and the name which is how the index will be accessed using the webservice:

<bean
   id="indexContextOne"
   class="ikube.model.IndexContext"
   property:indexName="indexOne"
   property:maxAge="${max.age}"
   property:compoundFile="${compound.file}"
   property:bufferedDocs="${buffered.docs}"
   property:bufferSize="${buffer.size}"
   property:batchSize="${jdbc.batch.size}"
   property:internetBatchSize="${internet.batch.size}"
   property:mergeFactor="${merge.factor}"
   property:maxFieldLength="${max.field.length}"
   property:maxReadLength="${max.read.length}"
   property:queueTimeout="${max.age}"
   property:throttle="${throttle}"
   property:indexDirectoryPath="${index.directory.path.one}"
   property:indexables-ref="indexables" />

Indexables are then defined for each 'datasource', like the site url and the database, for example a table indexable could be:

<bean
   id="tableOne"
   class="ikube.model.IndexableTable"
   property:name="faq"
   property:schema="db2admin"
   property:predicate="${faq.predicate}"
   property:primary="true"
   property:dataSource-ref="nonXaDataSource"
   property:children-ref="columnsOne" />
   <util:list id="columnsOne">
      <ref local="faqId" />
      <ref local="creationtimestamp" />
      <ref local="modifiedtimestamp" />
      <ref local="creator" />
      <ref local="modifier" />
      <ref local="question" />
      <ref local="answer" />
      <ref local="tableTwo" />
   </util:list>

Then the columns and their definitions. Here is one column. As you can see the Lucene fields are defined per column, which allows much flexibility in the search possibilities.

<bean
   id="creationtimestamp"
   class="ikube.model.IndexableColumn"
   property:name="creationtimestamp"
   property:fieldName="creationtimestamp"
   property:columnClass="java.sql.Timestamp" 
   property:analyzed="${analyzed}"
   property:stored="${stored}"
   property:vectored="${vectored}" />

Generally security is a factor in enterprise search, as such one important piece of functionality is not available. Any interested parties could contribute this with Spring security for example without too much effort.

Please refer to the documentation on the right for a complete configuration, or in the project folder. Configuration files are spring-client.xml in both the test packages and the integration packages.

Note that the documentation can only be displayed in Internet Explorer for some obscure reason. In anything else the Html gets displayed as text. If anyone can tell me why this is I would be very grateful indeed. 