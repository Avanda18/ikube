package ikube.integration;

import ikube.IConstants;
import ikube.cluster.IClusterManager;
import ikube.logging.Logging;
import ikube.model.IndexContext;
import ikube.model.Indexable;
import ikube.model.IndexableColumn;
import ikube.model.IndexableFileSystem;
import ikube.model.IndexableInternet;
import ikube.model.Server;
import ikube.model.faq.Attachment;
import ikube.model.faq.Faq;
import ikube.model.medical.Address;
import ikube.model.medical.Administration;
import ikube.model.medical.Condition;
import ikube.model.medical.Doctor;
import ikube.model.medical.Hospital;
import ikube.model.medical.Inpatient;
import ikube.model.medical.Medication;
import ikube.model.medical.Patient;
import ikube.model.medical.Person;
import ikube.model.medical.Record;
import ikube.model.medical.Treatment;
import ikube.service.ISearcherWebService;
import ikube.service.ServiceLocator;
import ikube.toolkit.ApplicationContextManager;
import ikube.toolkit.datageneration.DataGeneratorFour;
import ikube.toolkit.datageneration.IDataGenerator;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.persistence.EntityManager;
import javax.persistence.Persistence;

import org.apache.log4j.Logger;
import org.junit.Test;

/**
 * This test runs in its own Jenkins job. Typically it will be triggered by another job and will run along side other similar jobs
 * simulating a cluster. When the job finishes the index generated by the servers is tested.
 * 
 * @author Michael Couck
 * @since 20.12.10
 * @version 01.00
 */
public class Integration {

	static {
		Logging.configure();
	}

	private Logger logger = Logger.getLogger(this.getClass());

	@Test
	public void main() throws Exception {
		String osName = System.getProperty("os.name");
		logger.info("Operating system : " + osName);
		ApplicationContextManager.getApplicationContext();
		generateData();
		if (osName.toLowerCase().contains("server")) {
			Thread.sleep(1000 * 60 * 60 * 3);
			validateIndexes();
		}
		// TODO When the test ends then verify
		// the data and the index across the servers
	}

	private void validateIndexes() {
		List<Server> servers = ApplicationContextManager.getBean(IClusterManager.class).getServers();
		for (Server server : servers) {
			List<String> webServiceUrls = server.getWebServiceUrls();
			for (String webServiceUrl : webServiceUrls) {
				try {
					if (!webServiceUrl.contains(ISearcherWebService.class.getSimpleName())) {
						continue;
					}
					ISearcherWebService searchRemote = ServiceLocator.getService(ISearcherWebService.class, webServiceUrl,
							ISearcherWebService.NAMESPACE, ISearcherWebService.SERVICE);
					Map<String, IndexContext> indexContexts = ApplicationContextManager.getBeans(IndexContext.class);
					for (String contextName : indexContexts.keySet()) {
						IndexContext indexContext = indexContexts.get(contextName);
						String indexName = indexContext.getIndexName();
						String[] searchStrings = new String[] { "quick", "brown", "fox", "jumped", "over", "the", "lazy", "dog" };
						String[] searchFields = getSearchFields(indexContext);
						String results = searchRemote.searchMulti(indexName, searchStrings, searchFields, Boolean.TRUE, 0, 11);
						logger.info("Results : " + results);
					}
				} catch (Exception e) {
					// Swallow, gulp! Yummy?
					logger.warn("Exception accessing the web service : " + webServiceUrl, e);
				}
			}
		}
	}

	private String[] getSearchFields(IndexContext indexContext) {
		List<String> searchFieldsList = new ArrayList<String>();
		List<Indexable<?>> indexables = indexContext.getIndexables();
		for (Indexable<?> indexable : indexables) {
			getSearchFields(indexable, searchFieldsList);
		}
		return searchFieldsList.toArray(new String[searchFieldsList.size()]);
	}

	private void getSearchFields(Indexable<?> indexable, List<String> searchFieldsList) {
		String fieldName = null;
		if (IndexableColumn.class.isAssignableFrom(indexable.getClass())) {
			fieldName = ((IndexableColumn) indexable).getFieldName();
		} else if (IndexableInternet.class.isAssignableFrom(indexable.getClass())) {
			fieldName = ((IndexableInternet) indexable).getContentFieldName();
		} else if (IndexableFileSystem.class.isAssignableFrom(indexable.getClass())) {
			fieldName = ((IndexableFileSystem) indexable).getContentFieldName();
		}
		if (fieldName == null) {
			fieldName = "content";
		}
		searchFieldsList.add(fieldName);
		List<Indexable<?>> children = indexable.getChildren();
		if (children != null) {
			for (Indexable<?> child : children) {
				getSearchFields(child, searchFieldsList);
			}
		}
	}

	private void generateData() throws Exception {
		EntityManager entityManager = Persistence.createEntityManagerFactory(IConstants.PERSISTENCE_UNIT_NAME).createEntityManager();
		Class<?>[] classes = { Faq.class, Attachment.class, Hospital.class, Administration.class, Person.class, Doctor.class,
				Patient.class, Inpatient.class, Condition.class, Medication.class, Treatment.class, Record.class, Address.class };
		IDataGenerator dataGenerator = new DataGeneratorFour(entityManager, 10, classes);
		dataGenerator.before();
		dataGenerator.generate();
		dataGenerator.after();
	}

}