<?xml version="1.0" encoding="UTF-8"?>

<beans
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:util="http://www.springframework.org/schema/util"
	xmlns:property="http://www.springframework.org/schema/p"
	xmlns:transaction="http://www.springframework.org/schema/tx"
	xmlns:context="http://www.springframework.org/schema/context"

	xsi:schemaLocation="
			http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
			http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
            http://www.springframework.org/schema/util
            http://www.springframework.org/schema/util/spring-util.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context-3.0.xsd">
	
	<description>
		This file is not to be modified by users generally.
		This is the configuration for the beans used by Ikube. It contains the entity manager for Jpa,
		the handlers for the data sources and the schedulers for the timing of jobs.
	</description>

	<context:annotation-config />
	<context:component-scan base-package="ikube" />
	<transaction:annotation-driven transaction-manager="transactionManager"/>
	
	<bean
		id="ikube.IndexEngine"
		name="ikube.IndexEngine"
		class="ikube.IndexEngine"
		property:actions-ref="ikube.IndexEngine.actions"
		property:clusterManager-ref="ikube.cluster.IClusterManager" />

	<bean 
		class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor" />
	<bean 
		id="transactionManager" 
		class="org.springframework.orm.jpa.JpaTransactionManager" 
		property:entityManagerFactory-ref="entityManagerFactory" />
	<bean 
		id="entityManagerFactory" 
		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean" 
		lazy-init="false"
		property:jpaVendorAdapter-ref="jpaAdapter"
		property:jpaPropertyMap-ref="jpaPropertyMap"
		property:dataSource-ref="${ikube.dataSource}">
		<property name="loadTimeWeaver">
			<bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver" />
		</property>
		<property name="persistenceUnitName" value="${ikube.persistenceUnit}"></property>
	</bean>
	<bean 
		id="jpaAdapter" 
		class="org.springframework.orm.jpa.vendor.OpenJpaVendorAdapter"
		property:database="${ikube.dataSourceType}" 
		property:showSql="false" />
	<util:map id="jpaPropertyMap">
		<entry key="openjpa.ConnectionFactoryProperties" value="PrettyPrint=true,PrettyPrintLineLength=150" />
		<entry key="openjpa.Log" value="DefaultLevel=ERROR,JDBC=ERROR,SQL=ERROR,File=openjpa.log,Runtime=ERROR,Tool=ERROR" />

		<entry key="openjpa.DataCache" value="true(CacheSize=10000,SoftReferenceSize=10000)" />
		<entry key="openjpa.QueryCache" value="true(CacheSize=10000,SoftReferenceSize=10000)" />

		<entry key="openjpa.Optimistic" value="false" />
		<entry key="openjpa.ReadLockLevel" value="write" />
		<entry key="openjpa.WriteLockLevel" value="write" />
		<entry key="openjpa.NontransactionalRead" value="false" />
		<entry key="openjpa.LockTimeout" value="60000" />

		<entry key="openjpa.Multithreaded" value="true" />
		<entry key="openjpa.AutoDetach" value="commit" />
		<entry key="openjpa.FlushBeforeQueries" value="true" />
		<entry key="openjpa.RuntimeUnenhancedClasses" value="supported" />
		<entry key="openjpa.jdbc.DBDictionary" value="${ikube.jdbc.dictionary}" />
		
		<!-- <entry key="openjpa.Connection2UserName" value="${ikube.jdbc.userid}" />
		<entry key="openjpa.Connection2Password" value="${ikube.jdbc.password}" />
		<entry key="openjpa.Connection2URL" value="${ikube.jdbc.url}" />
		<entry key="openjpa.Connection2DriverName" value="${ikube.jdbc.driver}" />
		<entry key="openjpa.jdbc.SynchronizeMappings" value="buildSchema(ForeignKeys=true)" /> -->
	</util:map>

	<transaction:advice id="transactionAdvice" transaction-manager="transactionManager">
		<transaction:attributes>
			<transaction:method name="find*" />
			<transaction:method name="merge*" />
			<transaction:method name="persist*" />
			<transaction:method name="remove*" />
			<transaction:method name="execute*" />
		</transaction:attributes>
	</transaction:advice>

	<aop:config>
		<aop:pointcut id="dataBaseJpa" expression="execution(* ikube.database.jpa.DataBaseJpa.*(..))" />
		<aop:pointcut id="dataBaseAbstract" expression="execution(* ikube.database.jpa.ADataBaseJpa.*(..))" />
		<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseJpa" />
		<aop:advisor advice-ref="transactionAdvice" pointcut-ref="dataBaseAbstract"/>
	</aop:config>
	
	<!-- The Jpa database for large sets of data. -->
	<bean
		id="ikube.database.IDataBase"
		class="ikube.database.jpa.DataBaseJpa"
		lazy-init="false" />
	
	<bean
		id="ikube.cluster.cache.ICache"
		class="ikube.cluster.cache.CacheInfinispan"
		lazy-init="false"
		init-method="initialise"
		property:configurationFile="META-INF/infinispan.xml" />
	<bean
		id="ikube.cluster.IClusterManager"
		class="ikube.cluster.ClusterManager"
		lazy-init="true" 
		property:cache-ref="ikube.cluster.cache.ICache" />
	
	<!-- 
		These are just pojos that delegate to the real class that can be intercepted by Spring. 
	-->
	<bean 
		id="ikube.service.ISearchDelegate"
		class="ikube.service.SearchDelegate" />
	<bean 
		id="ikube.index.handler.IDocumentDelegate"
		class="ikube.index.handler.DocumentDelegate" />
	
	<!-- The handlers that do the indexing logic. -->
	<bean
		class="ikube.index.handler.internet.IndexableInternetHandler"
		property:threads="${internet.handler.threads}" 
		property:indexableClass="ikube.model.IndexableInternet"
		property:documentDelegate-ref="ikube.index.handler.IDocumentDelegate" />
	<bean
		class="ikube.index.handler.email.IndexableEmailHandler"
		property:threads="${email.handler.threads}"
		property:indexableClass="ikube.model.IndexableEmail" 
		property:documentDelegate-ref="ikube.index.handler.IDocumentDelegate" />
	<bean
		class="ikube.index.handler.filesystem.IndexableFilesystemHandler"
		property:threads="${filesystem.handler.threads}"
		property:indexableClass="ikube.model.IndexableFileSystem" 
		property:documentDelegate-ref="ikube.index.handler.IDocumentDelegate" />
	<bean
		class="ikube.index.handler.database.IndexableTableHandler"
		property:threads="${table.handler.threads}"
		property:indexableClass="ikube.model.IndexableTable" 
		property:documentDelegate-ref="ikube.index.handler.IDocumentDelegate" />
	<bean
		class="ikube.index.handler.filesystem.IndexableDictionaryHandler"
		property:threads="${filesystem.handler.threads}"
		property:indexableClass="ikube.model.IndexableDictionary" 
		property:documentDelegate-ref="ikube.index.handler.IDocumentDelegate" />

	<bean id="ikube.index.parse.mime.MimeMapper" class="ikube.index.parse.mime.MimeMapper">
		<constructor-arg value="/META-INF/mime/mime-mapping.xml" />
	</bean>
	<bean id="ikube.index.parse.mime.MimeTypes" class="ikube.index.parse.mime.MimeTypes">
		<constructor-arg value="/META-INF/mime/mime-types.xml" />
	</bean>
	
	<!-- The web services. -->
	<bean
		id="ikube.service.SearcherWebService"
		class="ikube.service.SearcherWebService"
		property:searchDelegate-ref="ikube.service.ISearchDelegate" />
	<bean
		id="ikube.service.MonitorWebService"
		class="ikube.service.MonitorWebService" />
	<bean
		id="ikube.service.WebServicePublisher"
		class="ikube.service.WebServicePublisher">
		<constructor-arg ref="ikube.cluster.IClusterManager" />
	</bean>
	
	<bean 
		id="ikube.listener.ListenerManager"
		class="ikube.listener.ListenerManager"
		destroy-method="removeListeners"
		property:listeners-ref="ikube.listener.ListenerManager.listeners" />
	<util:list id="ikube.listener.ListenerManager.listeners">
		<ref bean="ikube.IndexEngine" />
		<ref bean="ikube.monitoring.IMonitoringInterceptor" />
		<bean 
			class="ikube.listener.AliveListener"
			property:clusterManager-ref="ikube.cluster.IClusterManager" />
		<bean 
			class="ikube.listener.ClusterListener"
			property:clusterManager-ref="ikube.cluster.IClusterManager" />
		<bean 
			class="ikube.listener.MonitoringListener"
			property:clusterManager-ref="ikube.cluster.IClusterManager" />
	</util:list>
	
	<bean 
		id="ikube.listener.Scheduler" 
		class="ikube.listener.Scheduler"
		init-method="initialize"
		destroy-method="shutdown"
		property:schedules-ref="ikube.listener.Scheduler.schedules"
		property:listenerManager-ref="ikube.listener.ListenerManager" />
	<!-- The schedules that fire events to start actions. -->
	<util:list id="ikube.listener.Scheduler.schedules">
		<bean
			class="ikube.listener.Schedule"
			property:type="timer"
			property:delay="${delay}"
			property:period="${period}" />
		<bean
			class="ikube.listener.Schedule"
			property:type="alive"
			property:delay="60000"
			property:period="60000" />
		<bean
			class="ikube.listener.Schedule"
			property:type="clean"
			property:delay="600000"
			property:period="600000" />
		<bean
			class="ikube.listener.Schedule"
			property:type="performance"
			property:delay="60000"
			property:period="60000" />
	</util:list>
	
	<!-- 
		This is the mailer that will send mail to targets when things go right, and wrong in fact. This 
		you would want to modify, otherwise I will be getting many, many mails from your system. 
	-->
	<bean
		class="ikube.notify.Mailer"
		property:auth="true"
		property:mailHost="smtp.gmail.com"
		property:password="caherline"
		property:port="465"
		property:protocol="pop3"
		property:recipients="ikube.ikube@gmail.com"
		property:sender="ikube.ikube@gmail.com"
		property:user="ikube.ikube" />
	
</beans>